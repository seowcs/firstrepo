"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FinancialDocV1Config = exports.CustomDocConfig = exports.DocumentConfig = void 0;
const api_1 = require("../api");
const index_1 = require("./index");
const handler_1 = require("../errors/handler");
class DocumentConfig {
    constructor(documentClass, endpoints, documentType) {
        this.documentType = documentType;
        this.endpoints = endpoints;
        this.documentClass = documentClass;
    }
    async predictRequest(inputDoc, includeWords, cropping) {
        return await this.endpoints[0].predictReqPost(inputDoc, includeWords, cropping);
    }
    buildResult(inputFile, response) {
        const statusCode = response.messageObj.statusCode;
        if (statusCode === undefined || statusCode > 201) {
            const errorMessage = JSON.stringify(response.data, null, 2);
            handler_1.errorHandler.throw(new Error(`${this.endpoints[0].urlName} API ${statusCode} HTTP error: ${errorMessage}`));
            return new api_1.Response(this.documentClass, {
                httpResponse: response,
                documentType: this.documentType,
                input: inputFile,
                error: true,
            });
        }
        return new api_1.Response(this.documentClass, {
            httpResponse: response,
            documentType: this.documentType,
            input: inputFile,
            error: false,
        });
    }
    async predict(params) {
        this.checkApiKeys();
        await params.inputDoc.init();
        if (params.pageOptions !== undefined) {
            await this.cutDocPages(params.inputDoc, params.pageOptions);
        }
        const response = await this.predictRequest(params.inputDoc, params.includeWords, params.cropper);
        return this.buildResult(params.inputDoc, response);
    }
    async cutDocPages(inputDoc, pageOptions) {
        if (inputDoc.isPdf()) {
            await inputDoc.cutPdf(pageOptions);
        }
    }
    checkApiKeys() {
        this.endpoints.forEach((endpoint) => {
            if (!endpoint.apiKey) {
                throw new Error(`Missing API key for '${this.documentType}', check your Client configuration.
You can set this using the '${api_1.API_KEY_ENVVAR_NAME}' environment variable.\n`);
            }
        });
    }
}
exports.DocumentConfig = DocumentConfig;
class CustomDocConfig extends DocumentConfig {
    constructor({ endpointName, accountName, version, apiKey, }) {
        const endpoints = [
            new api_1.CustomEndpoint(endpointName, accountName, version, apiKey),
        ];
        super(index_1.CustomV1, endpoints, endpointName);
    }
}
exports.CustomDocConfig = CustomDocConfig;
class FinancialDocV1Config extends DocumentConfig {
    constructor(apiKey) {
        const endpoints = [
            new api_1.StandardEndpoint("invoices", "3", apiKey),
            new api_1.StandardEndpoint("expense_receipts", "3", apiKey),
        ];
        super(index_1.FinancialDocumentV1, endpoints);
    }
    async predictRequest(inputDoc, includeWords, cropping) {
        let endpoint;
        if (inputDoc.isPdf()) {
            endpoint = this.endpoints[0];
        }
        else {
            endpoint = this.endpoints[1];
        }
        return await endpoint.predictReqPost(inputDoc, includeWords, cropping);
    }
}
exports.FinancialDocV1Config = FinancialDocV1Config;

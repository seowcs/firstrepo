"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Field = exports.BaseField = void 0;
const geometry_1 = require("../geometry");
class BaseField {
    /**
     * @param {Object} prediction - Prediction object from HTTP response
     * @param {String} valueKey - Key to use in the prediction dict
     * @param {Boolean} reconstructed - Does the object is reconstructed (not extracted by the API)
     */
    constructor({ prediction, valueKey = "value", reconstructed = false, }) {
        /** The value. */
        this.value = undefined;
        this.reconstructed = reconstructed;
        if (prediction !== undefined &&
            prediction !== null &&
            valueKey in prediction &&
            prediction[valueKey] !== null) {
            this.value = prediction[valueKey];
        }
    }
    toString() {
        if (this.value !== undefined) {
            return `${this.value}`;
        }
        return "";
    }
}
exports.BaseField = BaseField;
class Field extends BaseField {
    /**
     * @param {Object} prediction - Prediction object from HTTP response
     * @param {String} valueKey - Key to use in the prediction dict
     * @param {Boolean} reconstructed - Does the object is reconstructed (not extracted by the API)
     * @param {Integer} pageId - Page ID for multi-page document
     * @param {Array<String>} extraFields - Extra fields to get from the prediction and to set as attribute of the Field
     */
    constructor({ prediction, valueKey = "value", reconstructed = false, pageId, }) {
        super({ prediction, valueKey, reconstructed });
        /**
         * Contains exactly 4 relative vertices coordinates (points) of a right
         * rectangle containing the field in the document.
         */
        this.bbox = [];
        /**
         * Contains the relative vertices coordinates (points) of a polygon containing
         * the field in the document.
         */
        this.polygon = [];
        this.pageId = pageId !== undefined ? pageId : prediction["page_id"];
        this.confidence = prediction.confidence ? prediction.confidence : 0.0;
        if (prediction.polygon) {
            this.polygon = prediction.polygon;
            this.bbox = (0, geometry_1.getBboxAsPolygon)(prediction.polygon);
        }
    }
    compare(other) {
        if (this.value === null && other.value === null)
            return true;
        if (this.value === null || other.value === null)
            return false;
        if (typeof this.value === "string") {
            return this.value.toLowerCase() === other.value.toLowerCase();
        }
        return this.value === other.value;
    }
    /**
    @param {Array<Field>} array1 - first Array of Fields
    @param {Array<Field>} array2 - second Array of Fields
    @param {String} attr - Attribute to compare
    @returns {Boolean} - true if all elements in array1 exist in array2 and vice-versa, false otherwise
     */
    static compareArrays(array1, array2, attr = "value") {
        const list1 = array1.map((item) => item[attr]);
        const list2 = array2.map((item) => item[attr]);
        if (list1.length !== list2.length)
            return false;
        for (const item1 of list1) {
            if (!list2.includes(item1))
                return false;
        }
        return true;
    }
    /**
     * @param {Array<Field>} array - Array of Fields
     * @returns {Number} product of all the fields probaility
     */
    static arrayConfidence(array) {
        let total = 1.0;
        for (const field of array) {
            total *= field.confidence;
            if (isNaN(total))
                return 0.0;
        }
        return total;
    }
    /**
     * @param {Array<Field>} array - Array of Fields
     * @returns {Number} Sum of all the Fields values in the array
     */
    static arraySum(array) {
        let total = 0.0;
        for (const field of array) {
            total += field.value;
            if (isNaN(total))
                return 0.0;
        }
        return total;
    }
}
exports.Field = Field;
